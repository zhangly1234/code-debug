对于iPerf编译的问题，今天想到是怎么回事了，其实很简单：iPerf的configuration找不到的是.a文件，这些是编译过程的中间产物，我们网上下载的编译好的二进制版本肯定把它们删掉了，因为相关的代码都已经链接到可执行文件里了。不知道为啥iPerf的configuration会去探测这些文件。所以我们只需要自己编译一个版本即可，非常简单。

下载musl-cross-make，然后修改一下配置文件，然后`make`即自动下载源码包，解压，编译。
然后`make install`，将`output`目录加入到环境变量。然后再编译一次，结果还是一样的错误。我去编译输出文件夹里看了,也用`find`命令全局搜索量，确实没有libssl.so或libssl.a.
用包管理器搜索，这些库（对于x86 ubuntu来说）是存在的。我想，实在不行就不要交叉编译了，直接用一个risc-v虚拟机里编译就是了。因为ubuntu on risc-v的包管理器里肯定有我们要的所有的库。

- 去官网下载ubuntu for riscv on qemu 镜像文件

- 创建一个新的虚拟机（ubuntu for riscv on qemu用的是新版本的qemu，怕和这个虚拟机里的旧版本qemu冲突）

这招也不行，ubuntu on riscv 不稳定，根本就启动不了（文件系统有问题，因此无法创建默认用户，造成无法登录），想要它启动，又得花大把时间，不值得。只能回到原来的交叉编译的路子上来。我查了一下[musl的文档](https://wiki.musl-libc.org/design-concepts.html)，musl基于文档中提到的设计原则，故意把这些“缺失”的.so文件全部合并到libc.so里，因此我们只能去修改./configuration脚本，让它不要去探测这些动态链接库。

我在configure文件里看了半天，发现`./configure --without-openssl` 就可以跳过这部分的编译了，然后就编译成功了......

至此我们获得了iPerf3的静态链接的可执行文件。接下来是修改rCore-Tutorial的easy-fs-fuse磁盘打包程序，让它添加这个可执行文件。

将`iPerf3`改成`iPerf3.bin`复制到user/external_binaries，
在`os/Makefile`里添加：
```makefile
fs-img: $(APPS)
	@cd ../user && make build TEST=$(TEST)
	@rm -f $(FS_IMG)
	@cp ../user/external_binaries/* ../user/target/riscv64gc-unknown-none-elf/release/
	@cd ../easy-fs-fuse && cargo run --release -- -s ../user/build/app/ -t ../user/target/riscv64gc-unknown-none-elf/release/

```
在`easy-fs-fuse/src/main.rs`里加入：
```rust
apps.push("iperf3".to_string());
```
这是比较临时性的做法。

居然报错了......看了下代码，可能是我文件名不对，我又去掉后缀名，改回`iperf3`了。

这回编译成功了，`iperf3`也出现在应用程序列表里了，尝试运行，又报错：
```rust
>> iperf3
[ INFO] uprobes_init
get_exec_path
get_exec_path succeeded. path = iperf3
[ INFO] uprobes: init sucess
[kernel] Exception(LoadPageFault) in application, bad addr = 0x32b8727f8, bad instruction = 0x1d876, kernel killed it.
[kernel] Segmentation Fault, SIGSEGV=11
```
可能是栈空间分配得不够多。现在是时候把[之前那一堆修改](https://github.com/chenzhiy2001/rCore-Tutorial-v3/commit/c64ae25ecee708c0257c9acb9da92309d32e1059)搬过来了。
这些修改中，和我们目前的任务相关的只有两个。

修改之后还是报错。我得先确认下是编译器的问题还是OS的问题。我先编译一个简单的C程序：
```c  
#include<stdio.h>
int main(){
	int a=1+1;
	printf("1+1=%d\n",&a);
	return 0;
}
```
这个简单的C程序也跑不起来。报错还是一样的：
```
>> one_plus_one
[ INFO] uprobes_init
get_exec_path
get_exec_path succeeded. path = one_plus_one
[ INFO] uprobes: init sucess
[kernel] Exception(LoadPageFault) in application, bad addr = 0x37801aff0, bad instruction = 0x1026e, kernel killed it.
[kernel] Segmentation Fault, SIGSEGV=11
```
我突然想到，是不是这些程序的入口地址和rCore-Tutorial里面的不一样。也就是说，这些程序在编译的时候就要遵守rCore-Tutorial的链接脚本：

```ld
/* user/src/linker.ld */

OUTPUT_ARCH(riscv)
ENTRY(_start)

BASE_ADDRESS = 0x10000;

SECTIONS
{
    . = BASE_ADDRESS;
    .text : {
        *(.text.entry)
        *(.text .text.*)
    }
    . = ALIGN(4K);
    .rodata : {
        *(.rodata .rodata.*)
    }
    . = ALIGN(4K);
    .data : {
        *(.data .data.*)
    }
    .bss : {
        *(.bss .bss.*)
    }
    /DISCARD/ : {
        *(.eh_frame)
        *(.debug*)
    }
}
```
将`linker.ld`放入iPerf3文件夹，在Makefile中：
```Makefile
CFLAGS = -g -O2 -Wall -Wl
```

这样修改是不行的，因为每次configure的时候这些参数都会被覆盖掉。不如先试试之前那个自己写的C程序。

我试着：
```shell
riscv64-linux-musl-gcc testC.c --static -T ~/linker.ld
```
报错：
```
`__EH_FRAME_BEGIN__' referenced in section `.text' of /home/oslab/musl-cross-make/output/bin/../lib/gcc/riscv64-linux-musl/9.4.0/crtbeginT.o: defined in discarded section `.eh_frame' of /home/oslab/musl-cross-make/output/bin/../lib/gcc/riscv64-linux-musl/9.4.0/crtbeginT.o
`__EH_FRAME_BEGIN__' referenced in section `.text' of /home/oslab/musl-cross-make/output/bin/../lib/gcc/riscv64-linux-musl/9.4.0/crtbeginT.o: defined in discarded section `.eh_frame' of /home/oslab/musl-cross-make/output/bin/../lib/gcc/riscv64-linux-musl/9.4.0/crtbeginT.o
collect2: 错误： ld 返回 1

```
这个问题不大，我们不要discard那两个段就是了，这不影响运行。去掉链接脚本中的discard部分后，成功编译了。尝试在rCore-Tutorial里跑一下，还是报和原来一样的错误。我怀疑BASE_ADDREESS还是没能成功设置，于是用readelf看了下：

```shell
oslab@ubuntu:~/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/external_binaries$ readelf one_plus_one -all
ELF 头：
  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  类别:                              ELF64
  数据:                              2 补码，小端序 (little endian)
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI 版本:                          0
  类型:                              EXEC (可执行文件)
  系统架构:                          RISC-V
  版本:                              0x1
  入口点地址：               0x10000
  程序头起点：          64 (bytes into file)
  Start of section headers:          128744 (bytes into file)
  标志：             0x5, RVC, double-float ABI
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         3
  Size of section headers:           64 (bytes)
  Number of section headers:         24
  Section header string table index: 23
```
入口点地址已经调整了。

我同学之前为了在rocket上跑，编译过一个iPerf，我试试他编译的能不能跑。

磁盘空间不够了，得那把磁盘空间调大。

结果有点意思，不再报LoadPageFault，而是加载了一会，然后报栈溢出：
```shell
>> iperf3
[ERROR] [kernel] Panicked at src/mm/heap_allocator.rs:9 Heap allocation error, layout = Layout { size: 8388608, align: 1 (1 << 0) }
---START BACKTRACE---
#0:ra=0x80219f12
#1:ra=0x80246fb6
#2:ra=0x8024690e
#3:ra=0x8022c026
#4:ra=0x80229dce
#5:ra=0x8020ea3c
---END   BACKTRACE---
make: *** [Makefile:94：run-inner] 错误 1
```
这也好办，增加栈的大小就是了：
```rust
const USER_HEAP_SIZE: usize = 32768*400;
```
报错还是类似：
```shell
>> iperf3
[ERROR] [kernel] Panicked at src/mm/heap_allocator.rs:9 Heap allocation error, layout = Layout { size: 8388608, align: 1 (1 << 0) }
---START BACKTRACE---
#0:ra=0x80219f12
```

我打算暂时先搁置这些问题，转而将现有的成果写成文档，方便后来者继续开发。