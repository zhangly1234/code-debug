1. 打算先换个角度。虽然内核和uprobe模块编译能过，但是有大量warning. 我应该先把warning都消掉。
2. 发现大部分warning都不是我干的，都是前人的代码...一部分是保留一些后续工作的接口，一部分是为了调试方便，多加了mut关键字。还有一部分是没用的import，这些我给去掉了。
3. 由于错误信息并未告知准确的出错代码位置，我只能多加一些Print来看看。好在print还是能正常运作的。
4. 由于fs_list_apps()函数正常输出了磁盘中的应用程序列表，所以我从这个函数之后的一个函数add_initproc()开始调试。add_initproc()经过测试没有问题：
```rust
fs::list_apps(); FINISHED
Will do 
 let _initproc = INITPROC.clone(); 

Done 
 let _initproc = INITPROC.clone(); 
```
- 注意到内核主函数里有行：`*DEV_NON_BLOCKING_ACCESS.exclusive_access() = true;`这个在旧版本的rCore-Tutorial里没有的，而且这里用到了报错的sync的exclusive_access函数。如果是这里出了错，那可能解决起来比较容易。加print看看。
- 不妙，错误不在这里。错误在`task::run_tasks();`里.
```rust
 will gain DEV_NON_BLOCKING_ACCESS 


 DEV_NON_BLOCKING_ACCESS gained 
 ```

- 在run_task里，添加输出：
```rust
pub fn run_tasks() {
    loop {
        println!("START");
        let mut processor = PROCESSOR.exclusive_access();
        println!("END");
```
结果很有趣，循环前两次是成功的，第三次失败了：
```shell
START
END
START
END
[ERROR] [kernel] Panicked at src/sync/up.rs:111 already borrowed: BorrowMutError
```
经过反复尝试，错误出现在`__switch`函数上，但是，__switch函数是用汇编写的，何来的borrow?
换个角度，可能是uprobe库里面添加了不必要的exclusive_access()方法调用。来找找看。

我确实在get_exec_path, get_new_page, set_writeable函数中加了exclusive_access()方法调用。然后谷歌搜了下，那个错误是由于已经被其他实体借用后再借用导致的（这个本来应该在编译时就检测出来的，不知道为啥运行的时候才报错）。
看来解决办法是去掉exclusive_access

exclusive_access()不是rust的官方core库提供的，而是rCore-Tutorial的作者自己写的。代码就在sync文件夹里。注意到一行注释：
```rust
    /// Panic if the data has been borrowed.
    pub fn exclusive_access(&self) -> UPIntrRefMut<'_, T> {
        INTR_MASKING_INFO.get_mut().enter();
        UPIntrRefMut(Some(self.inner.borrow_mut()))
    }
```
再加上readme中的说明：
> use `UPSafeCell` instead of `RefCell` or `spin::Mutex` in order to access static data structures and adjust its API so that it cannot be borrowed twice at a time(mention `& .exclusive_access().task[0]` in `run_first_task`)

还有rCore-Tutorial-Book上的：
> 另一方面是提供了 UPIntrFreeCell<T> 接口，代替了之前的 UPSafeCell<T> 。在Device OS 中把 UPSafeCell<T> 改为 UPIntrFreeCell<T> 。这是因为在第九章前，系统设置在S-Mode中屏蔽中断，所以在 S-Mode中运行的内核代码不会被各种外设中断打断，这样在单处理器的前提下，采用 UPSafeCell 来实现对可写数据的独占访问支持是够用的。但在第九章中，系统配置改为在S-Mode中使能中断，所以内核代码在内核执行过程中会被中断打断，无法实现可靠的独占访问。本章引入了新的 UPIntrFreeCell 机制，使得在通过 UPIntrFreeCell 对可写数据进行独占访问前，先屏蔽中断；而对可写数据独占访问结束后，再使能中断。从而确保线程对可写数据的独占访问时，不会被中断打断或引入可能的线程切换，而避免了竞态条件的产生。

看来之前的推测没错。就是数据已经被借用了，再借用直接panic了。
这也好办，不要获取数据，而是通过一个getter获取数据的拷贝就行。

观察进程控制块结构体：
```rust
pub struct ProcessControlBlock {
    // immutable
    pub pid: PidHandle,
    // mutable
    inner: UPIntrFreeCell<ProcessControlBlockInner>,
}
```
最简单的方式是把path和pid并列，而不是放在ProcessControlBlockInner里，但是这样就破坏rCore-Tutorial原有的设计了：外层放不变数据，内层（inner）放变化的数据（exec()之后path会变，所以path算可变数据）。而要获取内层数据，必须经过UPIntrFreeCell（这玩意大致就是“无中断容器”）的inner_exclusive_access. 这个设计对调试不太友好，不过还是有解决办法的，就是浅拷贝一份

不对，浅拷贝之前不还得inner_exclusive_access......绕不开啊。

不过，好消息是，至少uprobe库是成功引入了，否则根本就不会报这个错。

