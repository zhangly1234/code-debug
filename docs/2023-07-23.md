uprobe无法借用PCB的问题，只剩一个办法了，看下是谁借走了PCB，调整一下时序，让大家好借好还，再借不难。
这个办法本身很容易想到，但是之前没这么干，主要是因为有以下难点：

1. GDB attach不上，没法用调试器。
1. inner_exclusive_access() 是分散在代码里的，到处都是，光看代码很难厘清谁先谁后。只能通过添加输出信息，在运行的时候输出，才能知道具体顺序。
1. UPIntrFreeCell只是一个Cell，Cell本身不包含inner_exclusive_access()函数调用者的信息，所以，如果在UPIntrFreeCell里添加输出信息（这样只需要添加一行，很方便），是无法获悉函数调用者，或者UPIntrFreeCell包裹的内容的信息的（不能知道UPIntrFreeCell里包裹的信息，是因为被包裹对象不一定实现了Debug Trait，因此根本就没办法在UPIntrFreeCell的代码里面print，这样做连类型检查都过不去。这和py,js之类的动态语言不同。）。
	1. 除非引入Backtrace库，直接打印backtrace。但是，这个backtrace库是std里的。而且，引入新的库，说不准会引入新的麻烦。
1. 在调用inner_exclusive_access()处加print是可行的，但是通过全局搜索发现，inner_exclusive_access()在rCore-Tutorial里一共有七十个，数量比较多，得一个一个加print，一个一个分析。因为，通过之前的调试分析，发现在我出bug的那个瞬间，执行__switch的循环已经循环2-3次了，此时所有的模块都初始化完成了，都有可能是造成错误的原因。
1. 就算知道了是谁借走了PCB导致uprobe初始化模块不能再借用，也有可能没办法找到一种正确的借用顺序。

但是我们实在是没有其他办法了，只能硬上了。

加完print了，累死了，跑一跑试试。

不错，得到了一系列美观的输出：

```rust
**************/
Getting PCB in src/task/id.rs TaskUserRes::new()
Getting PCB in src/task/id.rs alloc_user_res()
Getting PCB in src/task/id.rs trap_cx_ppn()
Getting PCB in src/task/process.rs PCB::new()
Getting PCB in src/task/task.rs get_user_token()
Getting PCB in src/task/mod.rs suspend_current_and_run_next()
Getting PCB in src/task/mod.rs check_signals_of_current()
Getting PCB in src/task/task.rs get_user_token()
Getting PCB in src/task/mod.rs check_signals_of_current()
Getting PCB in src/task/task.rs get_user_token()
Getting PCB in src/task/process.rs PCB::fork()
Getting PCB AGAIN in src/task/process.rs PCB::fork()
[ERROR] [kernel] Panicked at src/sync/up.rs:111 already borrowed: BorrowMutError
```

看来这次运气不错，因为检查代码发现，“already borrowed”就是fork函数本身，也就是说我们在fork()函数里借了两次。不是那种两个函数借用的复杂情况。这个很好解决。在此处，我们借用PCB只是为了获取PCB中的path，不涉及页表修改，所以只需要在函数开头借用的时候就提前获取path即可。

代码修改好了，再跑一次。

成功了！！！！
```rust
Getting PCB in src/task/mod.rs suspend_current_and_run_next()
Getting PCB in src/task/process.rs PCB::exec()
Getting PCB AGAIN in src/task/process.rs PCB::exec()
Getting PCB AGAIN AGAIN in src/task/process.rs PCB::exec()
Getting PCB in src/task/id.rs alloc_user_res()
Getting PCB in src/task/id.rs trap_cx_ppn()
[ INFO] uprobes_init
get_exec_path
Getting PCB in src/task/mod.rs get_exec_path()
get_exec_path succeeded. path = user_shell
[ INFO] uprobes: init sucess
Getting PCB in src/task/mod.rs check_signals_of_current()
Getting PCB in src/task/task.rs get_user_token()
Getting PCB in src/task/task.rs get_user_token()
Getting PCB in src/syscall/fs.rs sys_write()
Rust user shell
Getting PCB in src/task/mod.rs check_signals_of_current()
Getting PCB in src/task/task.rs get_user_token()
Getting PCB in src/task/task.rs get_user_token()
```

当然，输出语句和等待输入的sys_read系统调用冲突了，我们无法在命令行中输入数据进一步验证功能是否可用。（而且用户态的负责注册uprobe的程序还没写），我得先把这七十行println注释掉（早知道用logger了）

好在这些输出语句的开头都是一样的`println!("Getting PCB`，因此可以用VSCode的全局搜索+全部替换。

再编译运行一次。看来uprobe启动成功了（不代表注册uprobe成功）。先跑一遍usertests。

```rust
[ INFO] uprobes_init
get_exec_path
get_exec_path succeeded. path = user_shell
[ INFO] uprobes: init sucess
Rust user shell
>>     
```

usertests通过了，而且，输出信息显示，fork()的同时uprobe也在新进程里初始化了。这也是个好消息

```shell
pidpid12: 1001
pid24: 1010
pid20: 1011
30: 1000
Usertests: Test forktree in Process 3 exited with code 0
Usertests: Running hello_world
[ INFO] uprobes_init
get_exec_path
get_exec_path succeeded. path = hello_world
[ INFO] uprobes: init sucess
Hello world from user mode program!
Usertests: Test hello_world in Process 3 exited with code 0
Usertests: Running huge_write
[ INFO] uprobes_init
get_exec_path
get_exec_path succeeded. path = huge_write
```
