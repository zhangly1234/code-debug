今天打算写完uprobe最后一部分。现在在修改side-stub和gdbserver的代码，修改的时候发现自己前边在内核里怎么做的都给忘了，还得回去照着代码写。因为这些通信机制没有写成一个完整的标准。


通信机制大致如下：
```
1. 用户在side-stub输入进程名+地址
2. side-stub脚本将 进程名+地址 转换为 GDB RSP 数据包："$vTUprogramName:0x80201234#checksum"
	- 之前的side-stub只需要调试内核，所以用户只需要输入地址即可，发送的数据包类似"$vTR0x80201234#checksum"
3. OS里的 gdbserver 进程 收到数据包，返回OK，将数据包转换成 uprobe注册命令 "uprobe_syncfunc$programName$0x80201234"，以系统调用的方式将这个字符串传递给内核进行处理。
	- 同时，eBPF程序也会传递给内核处理。
4. 内核里的bpf_attach函数接收这个字符串，传递给parse_tracepoint函数，从而在这个字符串中解析出一个三元组：(探针类型，地址（类似0x80200000），用户程序名)。
5. bpf_attach函数根据这个三元组和传递来的eBPF程序，注册uprobe.
```

为了适配uprobe，每一步都要再改！

先改第一步和第二步，增加一个新的side-stub命令:
```python
def tracepoint_user_program_then_get_registers(self,program_name,addr):
        command = 'vTU' # it's obvious that there should NOT be : in program_name,
        self.ser.write(('$'+command+program_name+':'+addr+'#'+hex(sum(command.encode('ascii')) % 256)[2:]).encode('ascii'))
```

第三步，修改OS里的gdbserver。这个简陋的标准库连strcat都没有，我们只能手动用循环拼接字符串。
```c
	char target[TARGET_STR_SIZE] = {'\0'}; //so many \0. correct?
	for(int i=0;i<strlen(ty_type);i++){
			target[i]=ty_type[i];
	}
	for(int i=0;i<TARGET_STR_SIZE-strlen(ty_type);i++){
		if(packet_buffer[packet_content_start+i]=='#'){
			target[strlen(ty_type)+i]='\0';
			break;
		}
		if(packet_buffer[packet_content_start+i]==':'){
			target[strlen(ty_type)+i]='$';
		}else{
			target[strlen(ty_type)+i]=packet_buffer[packet_content_start+i];
		}
	}
```
之前的eBPF程序还可以接着用，没有改动。其他的流程和注册vTR命令是一样的。

至于其他的部分，由于之前已经改好了，因此无需再改动。

接下来要实际测试一下。首先确定调试哪个用户态程序。由于我们把os里的name2addr功能给移除了，我们还得手动找到需要调试的地址。

我打算用matrix用户程序。这个程序的功能很简单，而且在main函数里会调用一个叫work的子函数。

我得先打印出它的符号表。在我查看存放编译输出的目录的时候，发现每个程序都多个一个.elf后缀的版本...这应该kprobe作者加的。先不管它。

我们可以用nm 工具查看符号表。但是函数名都被mangle过了，需要用rustfilt工具修改回来。

```shell
nm matrix | rustfilt > matrix_symbols.txt
```

不幸的是，work()函数被内联了，符号表里没有。

想要不内联，我们得把之前那套把戏（改链接脚本，改磁盘打包程序，改用户栈大小等等）再来一遍，但是此处我们只是想快速验证一下uprobe能不能用，那就先试试符号表里有，而且代码中出现的getpid(). 它的地址是0x_0001_097e.

此处也记录一下这个工具的使用流程在[文档](https://chenzhiy2001.github.io/code-debug-doc/chapter4/3syscall_and_arguments_tracing.html)中已经详细描述了。只要把文档中的tracepoint_then_get_registers替换成tracepoint_user_program_then_get_registers就可以了。

回车，报错。报错是正常的。调程序比较像《老人与海》。

来看看报错。好消息是，前边的流程都走对了，出错的是注册uprobe的步骤。

```shell
Rust user shell
>> ebpf_user_gdbserver
[ INFO] uprobes_init
get_exec_path
get_exec_path succeeded. path = ebpf_user_gdbserver
[ INFO] uprobes: init sucess
Received Packet:
$vTUmatrix:0x0001097e#1f
cmd = 1000
[ INFO] sys_bpf cmd: 1000, bpf_attr: 40168, size: 32
[TRACE] prog load attr
 prog_base:4630 prog_size=7744 map_base:9d20 map_num=0
[TRACE] bpf program load ex
[TRACE] symbol table
[ INFO] before compile
[TRACE] bpf object create (fd):70000000
[TRACE] bpf prog loadex finished!
[TRACE] load ex ret: 1879048192
cmd = 8
[ INFO] sys_bpf cmd: 8, bpf_attr: 40168, size: 32
[TRACE] target name str: uprobe_syncfunc$matrix$0x0001097e
[ERROR] [kernel] Panicked at src/ebpf/tracepoints.rs:280 called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }
---START BACKTRACE---
#0:ra=0x80219c3c
#1:ra=0x8024692a
#2:ra=0x8021dd96
#3:ra=0x802237d4
---END   BACKTRACE---
```

这回给出了具体的panic行数。发现是这行出了错：

```rust
let addr = addr_string[2..].parse::<usize>().unwrap();
```

先把add_string打印出来再说。

打印出来的结果是，addr_string是正常的：`addr string is "0x0001097e"`
这就怪了，因为这段程序在rust_playground里是能编译的。
在本地环境上单独拿出来编译试一试.程序如下：

```rust
fn main() {
    println!("Hello, world!");
    let addr_string:String = "0x0001097e".to_string();
    let b:usize = addr_string[2..].parse::<usize>().unwrap();
    println!("{:?}",b);
}
```
能编译通过。输出如下：
```shell
Hello, world!
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }', src/main.rs:4:53
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

我猜测是因为，去掉了"0x"之后，parse函数无法确定这个字符串代表几进制了，于是就panic了。这里是我犯傻了，为啥要去掉"0x"呢.......

改正后的版本如下：

```rust
let addr = addr_string.parse::<usize>().unwrap();
```

编译通过。但是我那个小例子还是会panic.

stackoverflow上找到另一种写法：

```rust
let addr:usize = usize::from_str_radix(&addr_string[2..], 16).unwrap();
```

这个版本可以了。重新编译，运行。

我在调试控制台（即和gdb交互的那个小窗口输入注册命令的时候，惊奇地发现没有报错。回终端一看）注册成功了:
```shell
>> ebpf_user_gdbserver
[ INFO] uprobes_init
get_exec_path
get_exec_path succeeded. path = ebpf_user_gdbserver
[ INFO] uprobes: init sucess
Received Packet:
$vTUmatrix:0x0001097e#1f
cmd = 1000
[ INFO] sys_bpf cmd: 1000, bpf_attr: 40168, size: 32
[TRACE] prog load attr
 prog_base:4630 prog_size=7744 map_base:9d20 map_num=0
[TRACE] bpf program load ex
[TRACE] symbol table
[ INFO] before compile
[TRACE] bpf object create (fd):70000000
[TRACE] bpf prog loadex finished!
[TRACE] load ex ret: 1879048192
cmd = 8
[ INFO] sys_bpf cmd: 8, bpf_attr: 40168, size: 32
[TRACE] target name str: uprobe_syncfunc$matrix$0x0001097e
addr string is "0x0001097e"
[ INFO] uprobes: add new path
[ INFO] uprobes: register success
[ INFO] uprobes: insert success
get_exec_path
get_exec_path succeeded. path = ebpf_user_gdbserver
[ INFO] uprobes: path=ebpf_user_gdbserver
get_exec_path
get_exec_path succeeded. path = ebpf_user_gdbserver
[TRACE] bpf prog attached! tracepoint addr: 1097e
```

gdbserver也和我们预期得一样，退出了，现在回到了终端。接下来是最关键的一步，运行`matrix`：

还是panic了，不过至少迈进了一大步。输出信息如下：

```shell
>> matrix
[ INFO] uprobes_init
get_exec_path
get_exec_path succeeded. path = matrix
get_new_page
[ERROR] [kernel] Panicked at src/mm/address.rs:115 assertion failed: `(left == right)`
  left: `2430`,
 right: `0`
---START BACKTRACE---
#0:ra=0x80219cc4
#1:ra=0x80246b4c
#2:ra=0x80227fd6
#3:ra=0x80221a42
#4:ra=0x80240adc
#5:ra=0x80242636
#6:ra=0x8022c790
#7:ra=0x8022385c
---END   BACKTRACE---
```

在运行matrix程序之前，uprobe成功地初始化并获得了这个程序的名字。然后要获得一个新页。显然是获取新页时出了问题。报错的那一行代码属于虚拟地址转换函数，这个函数用于将虚拟地址转换为虚拟页号。报错的这一行是在断言（assert）虚拟页号的offset是0。

解决办法很简单，先取整就行了。但是是floor（向下取整）还是ceiling（向上取整）？这本应该是rCore-Tutorial的API或者注释或者文档告诉我的，而不是我瞎猜的，因为在不同OS里这并不统一（之前发现rCore-Tutorial和rCore都不统一）

按照我的想法，应该是floor。但是痛苦的地方又来了，我们不知道是谁调用了这个出错的转换函数。推测最有可能的是`find_free_area`，因为这个函数是我添加的。

好在，通过全局搜索，我发现只有两个地方用到了这个出错的转换函数（而且还是我写的，也就意味着原来的rCore-Tutotial写了这个API但是没有使用）
```rust
        let p2 =  VirtPageNum::from(start_addr);
        let p3 = VirtPageNum::from(end_addr.0+PAGE_SIZE);//Page::of_addr(end_addr - 1) + 1;
```
改成
```rust
        let p2 =  start_addr.floor();//VirtPageNum::from(start_addr);
        let p3 = start_addr.ceil()//VirtPageNum::from(end_addr.0+PAGE_SIZE);//Page::of_addr(end_addr - 1) + 1;
```

顺便说下，注释里的`Page::of_addr(end_addr - 1) + 1`是大的rCore的代码。因为end_addr是开区间，所以要这样-1+1来达到ceil的效果。这么看来rCore-Tutorial的接口更人性化。之前我也注意到这两个函数了，但是以为floor和ceil返回的是地址而不是页号所以没有使用。

运行之后，旧的错误消失了，新的错误来了：
```shell
>> matrix
[ INFO] uprobes_init
get_exec_path
get_exec_path succeeded. path = matrix
get_new_page
[ERROR] [kernel] Panicked at src/mm/page_table.rs:115 vpn VPN:0x10 is mapped before mapping
---START BACKTRACE---
#0:ra=0x80219cc4
#1:ra=0x80246afa
#2:ra=0x802270be
#3:ra=0x80221a8c
#4:ra=0x80240a8a
#5:ra=0x802425e4
#6:ra=0x8022c73e
#7:ra=0x8022385c
---END   BACKTRACE---
```

这个错误信息说，我们想要map某个页，但是它已经被map过了。出错原因肯定是之前添加的页表操作函数。页表相关的代码之前已经反复推敲，试验许多次，但是还是有错。

查看代码发现可能导致这个问题的地方非常多。不过入口是唯一的（即get_new_page函数）再加上这些都是内核代码，不涉及断点组切换，或许可以在get_new_page处打断点，通过调试器来查找问题。

单步到库函数里，然后跑飞了。。。库函数无法跟踪，这是GDB的问题，不过只需要用step over即可。再来一次。

再调试了一次，确定了出错的语句：
```rust
current_proc.memory_set.push(MapArea::new(VirtAddr(addr), VirtAddr(addr+len), Framed, MapPermission::R | MapPermission::W| MapPermission::X| MapPermission::U), None);
```

在ruprobe库中找到以下代码：
```
    fn add_uprobepoint(&mut self){
        // get free point in user stack
        let addr = self.addr;
        unsafe {
            self.func_ebreak_addr = 
            get_new_page(addr, 2);
        }
        unsafe {
            self.slot_addr = 
            get_new_page(addr, 6);
        }
```

这段代码是照搬老的rCore版本的uprobe的，到我这就不行了。注意这里调用了两次get_new_page，请求的地址居然是一样的。这段代码在大的rCore里正常运作，但是到了rCore-Tutorial就不行了，这说明大的rCore的push和rCore-Tutorial的push函数虽然名字一样，但是实现细节有不同。我推测是，大的rCore如果发现你请求的push的区域已经被使用，就会自动在这个区域后边找一个空闲区域，但是rCore-Tutorial不会这么做，反而会直接panic。

上一段的推测被推翻了，rCore和rCore-Tutorial的push()函数的机制是一致的。问了rCore版本的原作者，他说向同一个地址请求两遍get_new_page不影响，因为有find_free_area子函数帮忙解决这个冲突。这提醒到我了，我也在rCore-Tutorial-v3里实现了find_free_area函数并且调用了，但是并没有使用得到的free_area。

参考rCore，将上述出错语句改为：
```rust
current_proc.memory_set.push(MapArea::new(ebreak_addr, VirtAddr(ebreak_addr.0+len), Framed, MapPermission::R | MapPermission::W| MapPermission::X| MapPermission::U), None);
```

重新编译，运行，发现这个错误解决了。

但是又出现新的错误：
```shell
>> matrix
[ INFO] uprobes_init
get_exec_path
get_exec_path succeeded. path = matrix
get_new_page
get_new_page
set_writable
[ERROR] [kernel] Panicked at src/mm/mod.rs:46 called `Option::unwrap()` on a `None` value
---START BACKTRACE---
#0:ra=0x80219cc4
#1:ra=0x80246af2
#2:ra=0x80240aa0
#3:ra=0x802425dc
#4:ra=0x8022c736
#5:ra=0x80223854
---END   BACKTRACE---
```

出错的语句是：
```rust
let mut page_table_entry = current_proc.memory_set.page_table.translate(VirtPageNum(addr & !(crate::config::PAGE_SIZE - 1))).unwrap();
```
出错的原因是，我在将地址转换为页号的时候，忘记做最后一步运算了。

修改为：
```rust
let mut page_table_entry = current_proc.memory_set.page_table.translate(VirtPageNum((addr & !(crate::config::PAGE_SIZE - 1))/crate::config::PAGE_SIZE)).unwrap();
```

从这里可以发现rust的错误处理语法的好处。如果让这些错误到运行的时候再暴露出来，就非常难debug了。

这个错误解决了。新错误：

```shell
>> matrix
[ INFO] uprobes_init
get_exec_path
get_exec_path succeeded. path = matrix
get_new_page
get_new_page
set_writable
[ERROR] [kernel] Panicked at src/trap/mod.rs:216 Unsupported trap from kernel: Exception(LoadPageFault), stval = 0x1097e!
---START BACKTRACE---
#0:ra=0x80219cc4
#1:ra=0x80246aec
#2:ra=0xfffffffffffff10c
#3:ra=0x802425d6
#4:ra=0x8022c730
#5:ra=0x8022384e
---END   BACKTRACE---

```

这是个缺页异常。其中stval就是我们请求插桩的地址。这就离谱了，我们请求插桩的页肯定是已经存在的页，为何会缺页？彭淳毅说是可写（set_writable）没设置成功。这很可能是原因，因为这段代码我用了一些位操作，容易出错，而大的rCore已经将这些操作封装好了，所以在大的rCore里是直接调用现有的位操作函数的，不像在rCore-tutorial里我们得手动进行位操作，容易出错。

检查set_writable函数。首先发现，在设置页表项可写之前，我并没有获得那个页表项的指针，而是复制了一个页表项，那再怎么改也没用阿......

将复制改为借用之后，还是报缺页错误，这回应该是我位操作的问题了。

位操作检查了一下，正确无误，那可能是获取的页表项是错的。

再次回头查看获取页表项的代码：

```rust
let mut page_table_entry = &mut(current_proc.memory_set.page_table.translate(VirtPageNum((addr & !(crate::config::PAGE_SIZE - 1))/crate::config::PAGE_SIZE)).unwrap());
```

其中，`VirtPageNum((addr & !(crate::config::PAGE_SIZE - 1))/crate::config::PAGE_SIZE`是为了将虚拟地址转换为虚拟页号。这个之前不是有现成函数吗，为啥不用.....

将其改为

```rust
let page_table_entry = &mut(current_proc.memory_set.page_table.translate(VirtPageNum::from(VirtAddr(addr))).unwrap());
```
另外，我特地查看了下VirtPageNum::from的源码，证实了我的地址转页号的代码是错误的。

修改之后还是报错。错因之前出现过，就是地址有offset。改为floor()即可。

改为floor()之后，又报和之前同样的缺页错误了.....

好在查了rCore-Tutorial-v3文档后，发现这一段代码有比较详细的解释，其中有这么一段：

> 第 3 行我们让编译器自动为 PageTableEntry 实现 Copy/Clone Trait，来让这个类型以值语义赋值/传参的时候不会发生所有权转移，而是拷贝一份新的副本。从这一点来说 PageTableEntry 就和 usize 一样，因为它也只是后者的一层简单包装，并解释了 usize 各个比特段的含义。

或许，我把那些位操作写成 PageTableEntry 里的一个方法（也就是写一个setter）就能解决这个问题了。

不行，还是报同样的缺页错误。或许不知需要write权限？

我做了两个修改：
1. 写了一个set_everything setter.
1. 不引用页表项，而是直接调用setter.

还是没用。加了一些print，相关数据也都没错，页表项确实是改了的。

我想起来符号表里getpid的完整名称：

`000000000001097e T user_lib::task::getpid`

会不会因为它是user_lib里的，不是代码里的，所以这个地址实际上无法跟踪？那我换一个用户程序看看。

也不用换用户程序，我发现符号表里有main函数，看看main能不能插装。

main也不行。

在rCore-Tutorial-v3文档中读到这样一段：
> 同样，我们手动修改一个页表项之后，也修改了映射，但 TLB 并不会自动刷新清空，我们也需要使用 sfence.vma 指令刷新整个 TLB。注：可以在 sfence.vma 指令后面加上一个虚拟地址，这样 sfence.vma 只会刷新TLB中关于这个虚拟地址的单个映射项。

抱着试一试的心态加了，也没用。

还有一个可能的错因，就是，os真正运行的是matrix.bin而不是matrix，在将matrix处理成matrix.bin的时候（主要工作是去掉符号表），一些地址发生了变化。

我在matrix函数里加了输出，直接在程序里面输出程序的地址，这证明上一段的猜测不对。向老师说还是我页表项改错了。
